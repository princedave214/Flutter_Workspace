Module 9: Animations and Transitions in Flutter, covering both theory and practical assignments with examples:

Theory Assignments
1. Difference between Implicit and Explicit Animations in Flutter

Implicit Animations:

Flutter automatically handles the animation for you when a property changes.

They are simpler to implement but offer less control.

Example Widgets: AnimatedContainer, AnimatedOpacity, AnimatedAlign, AnimatedPadding.

Use case: Simple animations like changing a button’s color or size on tap.

Explicit Animations:

You have full control over the animation, including duration, curve, and the value changes.

Requires an AnimationController and Animation object.

Example Widgets: FadeTransition, SlideTransition, ScaleTransition.

Use case: Complex animations, custom sequences, or looping animations.

Summary Table:

Feature	                Implicit Animation	  Explicit Animation
Control over animation	Low	                  High
Complexity	        Simple	                  More complex
Example	                AnimatedContainer	  FadeTransition
2. Purpose of AnimationController and its Usage

AnimationController is the core object for explicit animations in Flutter.

Controls the animation’s duration, start, stop, reverse, and repeat.

It requires a TickerProvider (usually provided by a StatefulWidget with SingleTickerProviderStateMixin).

Example Usage:

class MyAnimation extends StatefulWidget {
  @override
  _MyAnimationState createState() => _MyAnimationState();
}

class _MyAnimationState extends State<MyAnimation> with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: Duration(seconds: 2),
      vsync: this,
    )..repeat(reverse: true); // Animation repeats back and forth
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _controller,
      child: Container(
        width: 100,
        height: 100,
        color: Colors.blue,
      ),
    );
  }
}

3. Concept of Hero Animations

Hero Animation: A Flutter feature that automatically animates a widget from one screen to another, creating a smooth visual transition.

Useful for images, cards, or avatars that appear on multiple screens.

Requires:

Both source and destination widgets must use Hero widget.

Both Hero widgets must have the same tag.

Example:

// Screen 1
Hero(
  tag: 'profilePic',
  child: Image.asset('assets/profile.png', width: 100),
);

// Screen 2
Hero(
  tag: 'profilePic',
  child: Image.asset('assets/profile.png', width: 300),
);

Practical Assignments
1. Button that Animates Size and Color (Implicit Animation)
class AnimatedButton extends StatefulWidget {
  @override
  _AnimatedButtonState createState() => _AnimatedButtonState();
}

class _AnimatedButtonState extends State<AnimatedButton> {
  bool _tapped = false;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: GestureDetector(
        onTap: () {
          setState(() {
            _tapped = !_tapped;
          });
        },
        child: AnimatedContainer(
          duration: Duration(seconds: 1),
          width: _tapped ? 200 : 100,
          height: _tapped ? 60 : 50,
          decoration: BoxDecoration(
            color: _tapped ? Colors.blue : Colors.red,
            borderRadius: BorderRadius.circular(12),
          ),
          alignment: Alignment.center,
          child: Text(
            'Tap Me',
            style: TextStyle(color: Colors.white, fontSize: 18),
          ),
        ),
      ),
    );
  }
}

2. Hero Animation Between Screens
// Screen 1
GestureDetector(
  onTap: () {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => SecondScreen()),
    );
  },
  child: Hero(
    tag: 'hero-image',
    child: Image.asset('assets/pic.png', width: 100),
  ),
);

// Screen 2
Hero(
  tag: 'hero-image',
  child: Image.asset('assets/pic.png', width: 300),
);

3. Loading Animation for Data Fetching
class LoadingDemo extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: CircularProgressIndicator(), // Built-in Flutter loader
    );
  }
}


For a more custom animation, you can combine AnimatedBuilder with AnimationController:

class SpinningBox extends StatefulWidget {
  @override
  _SpinningBoxState createState() => _SpinningBoxState();
}

class _SpinningBoxState extends State<SpinningBox> with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: Duration(seconds: 2),
      vsync: this,
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: AnimatedBuilder(
        animation: _controller,
        child: Container(width: 50, height: 50, color: Colors.blue),
        builder: (context, child) {
          return Transform.rotate(
            angle: _controller.value * 6.3, // rotates from 0 to ~2π
            child: child,
          );
        },
      ),
    );
  }
}